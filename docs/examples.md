# examples

## udp echo server
```c++
#include "yasio/yasio.hpp"

using namespace yasio::inet;

void yasio_echo_server(const char *ip, u_short port)
{
  io_service udp_server;
  udp_server.set_option(YOPT_NO_NEW_THREAD, 1);

  // !important, because we set YOPT_NO_NEW_THREAD, so need a timer to start server
  deadline_timer starter(udp_server);
  starter.expires_from_now(std::chrono::seconds(1));
  starter.async_wait([&](bool) {
    udp_server.set_option(YOPT_CHANNEL_LFBFD_PARAMS, 0, 65535, -1, 0, 0);
    udp_server.open(0, YCM_UDP_SERVER);
  });

  io_hostent endpoints[] = {{ip, port}};
  udp_server.start_service(endpoints, [&](event_ptr ev) {
    switch (ev->kind())
    {
      case YEK_PACKET:
        udp_server.write(ev->transport(), std::move(ev->packet()));
        break;
    }
  });
}

int main(int argc, char **argv)
{
  if (argc > 2)
    yasio_echo_server(argv[1], atoi(argv[2]));
  return 0;
}
```

## http client
```lua
-- This file is generated by x-studio365 10.0.5900.11 © 2019, All rights reserved.
-- File Name: http_client.lua
-- Module: http_client, <please write module description>
-- Author: halx99
-- Create Date: [2019-04-08 17:46:47]

local _M = {}

--[[
parse a url
retval: {
  protocol = 'http', -- or 'https'
  host = 'ip138.com'
  path = '/xxx/xxx',
  port = '80', -- or 443 for https, or specificed by url: http://ip138.com:80/index.htm
}
]]
function _M:parseUrl(url)
    local params = {}
    local colon = url:find(':')
    if not colon then return nil end

    params.protocol = url:sub(1, colon - 1)

    -- host start, skip '://'
    local start = colon + 3 -- 

    -- Finally, predicated is path offset or nil
    local predicated = url:find('[:/]', start)
    if predicated then
        params.host = url:sub(start, predicated - 1)

        local ch = url:sub(predicated, predicated)
        if ch == ':' then -- url have specificed port
            colon = predicated
            predicated = url:find('/', predicated + 1)
            if predicated then
                params.port = tonumber(url:sub(colon + 1, predicated - 1))
            else
                params.port = tonumber(url:sub(colon + 1))
            end
        end
    else
        params.host = url:sub(start)
    end

    if predicated then 
        params.path = url:sub(predicated)
    else 
        params.path = '/'
    end
    
    -- No port present in url, set default port for protocol
    if params.port == nil then
        if params.protocol == 'http' then
            params.port = 80
        elseif params.protocol == 'https' then
            params.port = 443
        else
            params.port = 80
        end
    end
    
    return params
end

function _M:ctor(count)
    local service = yasio.io_service.new()

    local channelIndexs = {}
    local channels = {}
    for i=1,count do
        channels[#channels + 1] = {host='0.0.0.0', port=0} -- the dummy endpoint
        channelIndexs[#channelIndexs + 1] = i - 1
    end
    self.channelIndexs = channelIndexs

    self.requests = {}

    service:start_service(channels, function(ev)
            local t = ev:kind()
            local cindex = ev:cindex()
            local requestItem = self.requests[cindex]
            if requestItem == nil then return end
            if t == yasio.YEK_PACKET then
                local ibs = ev:packet()
                requestItem.responseData = requestItem.responseData .. ibs:to_string()
            elseif(t == yasio.YEK_CONNECT_RESPONSE) then -- connect responseType
                if(ev:status() == 0) then
                    local transport = ev:transport()
                    service:write(transport, requestItem.requestData)
                else
                    print("connect server failed!")
                    self.requests[cindex] = nil
                end
            elseif(t == yasio.YEK_CONNECTION_LOST) then -- connection lost event
                print("The http connection is lost!")
                requestItem.requestCallback(requestItem.responseData)
                self.requests[cindex] = nil
            end
        end)

    self.service = service
end

function _M:sendHttpGetRequest(url, callback)
    -- find a idle channel to send request

    local params = self:parseUrl(url)
    if(params == nil) then
        print('yasio.http_client: invalid url: ' .. url)
        return false
    end

    if(params.protocol ~= 'http') then
        print('yasio.http_client: only http supported currently, url=' .. url)
        return false;
    end

    local idleChannelIndex = -1
    for _,v in ipairs(self.channelIndexs) do
        if(self.requests[v] == nil) then
            idleChannelIndex = v
            break
        end
    end

    if(idleChannelIndex ~= -1) then
        local requestItem = {
            requestData = string.format("GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36\r\nAccept: */*;q=0.8\r\nConnection: Close\r\n\r\n",
                params.path,
                params.host
            ),
            requestCallback = callback,
            responseData = ""
        }
        self.requests[idleChannelIndex] = requestItem
        self.service:set_option(yasio.YOPT_CHANNEL_REMOTE_ENDPOINT, idleChannelIndex, params.host, params.port)
        self.service:open(idleChannelIndex, yasio.YCM_TCP_CLIENT)
        return true
    else
        print('yasio.http_client: no idle channel to send http request for url: ' .. url)
        return false
    end
end

function _M:update()
    self.service:dispatch_events(128)
end

_M:ctor(20)

return _M
```

## yasio-ni dllimport list
```c#
const string LIBNAME = "yasio-ni";

public delegate void YNIEventDelegate(uint emask, int cidx, IntPtr thandle, IntPtr bytes, int len);
public delegate void YNIPrintDelegate(string msg);
/// <summary>
/// Start a low level socket io service
/// </summary>
/// <param name="strParam">
/// format: "ip:port;ip:port;ip:port"
/// </param>
/// <param name="d"></param>
/// <returns></returns>
[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern int yasio_start(string strParam, YNIEventDelegate d);

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_open(int cindex, int cmask);

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_close(int cindex);

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_close_handle(IntPtr thandle);

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_write(IntPtr thandle, byte[] bytes, int len);

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_dispatch_events(int maxEvents);

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_set_option(int opt, string strParam);
[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern void yasio_stop();

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern long yasio_highp_time();

[DllImport(LIBNAME, CallingConvention = CallingConvention.Cdecl)]
public static extern long yasio_set_print_fn(YNIPrintDelegate callback);
```

## Remote Debug based on TCP
典型的基于TCP的服务端客户端远程调试示例，使用yasio的io_servcie实现，调试后端和调试前端无需自己开线程，直接使用服务线程处理调试协议即可。协议头一般定义为如下方式即可：
```C++
// odbk_proto_header
struct odbk_proto_header {
  int total_size;
  int version;
  uint8_t reserved; // future: compressed/encrypted
  uint8_t cmd; // 
};
// 例如调试后端将打印消息包封装
std::vector<char> odbkp_create_msg(int type, const std::string &msg)
{
  yasio::obstream obs;
  obs.push32();
  obs.write_i(ODBKP_VERSION);
  obs.write_i((uint8_t)proto_code::EV_MESSAGE);
  obs.write_i<uint8_t>(0);
  obs.write_va(msg);
  obs.pop32(obs.length());
  return std::move(obs.buffer());
}
```

```C++
// ****************** server ***************************
io_hostent ep("0.0.0.0", 'odbk' % 65536); // 25195
yasio_shared_service->start_service(&ep, [=](event_ptr e) {
auto k = e->kind();
if (k == YEK_PACKET)
{
    ibstream ibs(std::move(e->packet()));
    ibs.seek(sizeof(int), SEEK_CUR); // skip length field
    uint32_t proto_version = ibs.read_i<uint32_t>();
    // TODO: check version?
    uint8_t cmd = ibs.read_i<uint8_t>(); // cmd
    // call different handler with different cmd
}
else if (k == YEK_CONNECT_RESPONSE)
{
    if (e->status() == 0)
    {
    printf("Accept frontend succeed."); // debug session estiblished with socket.
    // this->session = e->transport(); // 保存通讯session用于发送数据, m_session是transport_handle_t类型
    }
    else
    {
    printf("Accept frontend exception: %d", e->status());
    }
}
else if (k == YEK_CONNECTION_LOST)
{
    printf("The connection with frontend is lost: %d, waiting new to income...", e->status());
}
});
yasio_shared_service->set_option(YOPT_CHANNEL_LFBFD_PARAMS,
    0, -- channelIndex  
    65535, -- maxFrameLength
    0,  -- lenghtFieldOffset
    4, -- lengthFieldLength
    0 -- lengthAdjustment
);
yasio_shared_service->set_option(YOPT_DEFER_EVENT, 0); // 禁用事件队列，网络事件直接在服务线程分派
yasio_shared_service->open(0, YCM_TCP_SERVER);

// ********************* client ***********************
// start process, always try to connect local odbk backend
io_hostent ep("127.0.0.1", 'odbk' % 65536); // 25195
yasio_shared_service->start_service(&ep, [=](event_ptr e) {
    auto k = e->kind();
    if (k == YEK_PACKET)
    {
        ibstream ibs(std::move(e->packet()));
        ibs.seek(sizeof(int), SEEK_CUR); // skip length field
        uint32_t proto_version = ibs.read_i<uint32_t>();
        // TODO: check version?
        uint8_t cmd = ibs.read_i<uint8_t>(); // cmd
        // call different handler with different cmd
    }
    else if (k == YEK_CONNECT_RESPONSE)
    {
        if (e->status() == 0)
        {
            printf("connect backend succeed."); // debug session estiblished with socket.
            // 保存通讯session用于发送数据
            // m_session = e->transport(); // m_session是transport_handle_t类型
        }
        else
        {
            printf("Accept frontend exception: %d", e->status());
        }
    }
    else if (k == YEK_CONNECTION_LOST)
    {
        printf("The connection with backend is lost: %d, waiting new to income...", e->status());
    }
    });
yasio_shared_service->set_option(YOPT_CHANNEL_LFBFD_PARAMS,
    0, -- channelIndex  
    65535, -- maxFrameLength
    0,  -- lenghtFieldOffset
    4, -- lengthFieldLength
    0 -- lengthAdjustment
);
yasio_shared_service->set_option(YOPT_DEFER_EVENT, 0); // 禁用事件队列，网络事件直接在服务线程分派
yasio_shared_service->open(0, YCM_TCP_CLIENT);
```

## IPV6 ONLY reference
http://blog.csdn.net/baidu_25743639/article/details/51351638  
http://www.cnblogs.com/SUPER-F/p/IPV6.html
